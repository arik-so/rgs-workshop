import { COption_NoneZ } from '../enums/COption_NoneZ.mjs';
import { Currency } from '../enums/Currency.mjs';
import { Result_SecretKeyErrorZ } from '../structs/Result_SecretKeyErrorZ.mjs';
import { Result_PublicKeyErrorZ } from '../structs/Result_PublicKeyErrorZ.mjs';
import { TxCreationKeys } from '../structs/TxCreationKeys.mjs';
import { HTLCOutputInCommitment } from '../structs/HTLCOutputInCommitment.mjs';
import { RouteParameters } from '../structs/RouteParameters.mjs';
import { Option_u64Z } from '../structs/Option_u64Z.mjs';
import { ChannelDetails } from '../structs/ChannelDetails.mjs';
import { Result_RouteLightningErrorZ } from '../structs/Result_RouteLightningErrorZ.mjs';
import { Result_COption_ClosureReasonZDecodeErrorZ } from '../structs/Result_COption_ClosureReasonZDecodeErrorZ.mjs';
import { Result_COption_HTLCDestinationZDecodeErrorZ } from '../structs/Result_COption_HTLCDestinationZDecodeErrorZ.mjs';
import { OutPoint } from '../structs/OutPoint.mjs';
import { Result_COption_EventZDecodeErrorZ } from '../structs/Result_COption_EventZDecodeErrorZ.mjs';
import { Logger } from '../structs/Logger.mjs';
import { NetworkGraph } from '../structs/NetworkGraph.mjs';
import { Result_COption_NetworkUpdateZDecodeErrorZ } from '../structs/Result_COption_NetworkUpdateZDecodeErrorZ.mjs';
import { Result_C2Tuple_PaymentHashPaymentSecretZNoneZ } from '../structs/Result_C2Tuple_PaymentHashPaymentSecretZNoneZ.mjs';
import { Result_PaymentSecretNoneZ } from '../structs/Result_PaymentSecretNoneZ.mjs';
import { ChannelMonitor } from '../structs/ChannelMonitor.mjs';
import { Watch } from '../structs/Watch.mjs';
import { BroadcasterInterface } from '../structs/BroadcasterInterface.mjs';
import { KeysInterface } from '../structs/KeysInterface.mjs';
import { FeeEstimator } from '../structs/FeeEstimator.mjs';
import { ChannelManager } from '../structs/ChannelManager.mjs';
import { Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ } from '../structs/Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.mjs';
import { Result_StringErrorZ } from '../structs/Result_StringErrorZ.mjs';
import { Result_COption_MonitorEventZDecodeErrorZ } from '../structs/Result_COption_MonitorEventZDecodeErrorZ.mjs';
import { Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ } from '../structs/Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.mjs';
import { Result_InvoiceSignOrCreationErrorZ } from '../structs/Result_InvoiceSignOrCreationErrorZ.mjs';
import { Score } from '../structs/Score.mjs';
import { UserConfig } from '../structs/UserConfig.mjs';
import { ExpandedKey } from '../structs/ExpandedKey.mjs';
import { Sha256 } from '../structs/Sha256.mjs';
import { CommonBase, UInt5 } from './CommonBase.mjs';
export declare class UtilMethods extends CommonBase {
    /**
     * Constructs a new COption_NoneZ containing a
     */
    static constructor_COption_NoneZ_some(): COption_NoneZ;
    /**
     * Constructs a new COption_NoneZ containing nothing
     */
    static constructor_COption_NoneZ_none(): COption_NoneZ;
    /**
     * Read a ClosureReason from a byte array, created by ClosureReason_write
     */
    static constructor_ClosureReason_read(ser: Uint8Array): Result_COption_ClosureReasonZDecodeErrorZ;
    /**
     * Read a HTLCDestination from a byte array, created by HTLCDestination_write
     */
    static constructor_HTLCDestination_read(ser: Uint8Array): Result_COption_HTLCDestinationZDecodeErrorZ;
    /**
     * Read a Event from a byte array, created by Event_write
     */
    static constructor_Event_read(ser: Uint8Array): Result_COption_EventZDecodeErrorZ;
    /**
     * Creates a digital signature of a message given a SecretKey, like the node's secret.
     * A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
     * Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
     */
    static constructor_sign(msg: Uint8Array, sk: Uint8Array): Result_StringErrorZ;
    /**
     * Recovers the PublicKey of the signer of the message given the message and the signature.
     */
    static constructor_recover_pk(msg: Uint8Array, sig: string): Result_PublicKeyErrorZ;
    /**
     * Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
     * and the PublicKey.
     */
    static constructor_verify(msg: Uint8Array, sig: string, pk: Uint8Array): boolean;
    /**
     * Construct the invoice's HRP and signatureless data into a preimage to be hashed.
     */
    static constructor_construct_invoice_preimage(hrp_bytes: Uint8Array, data_without_signature: UInt5[]): Uint8Array;
    /**
     * Read a MonitorEvent from a byte array, created by MonitorEvent_write
     */
    static constructor_MonitorEvent_read(ser: Uint8Array): Result_COption_MonitorEventZDecodeErrorZ;
    /**
     * Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
     */
    static constructor_C2Tuple_BlockHashChannelMonitorZ_read(ser: Uint8Array, arg: KeysInterface): Result_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ;
    /**
     * Read a C2Tuple_BlockHashChannelManagerZ from a byte array, created by C2Tuple_BlockHashChannelManagerZ_write
     */
    static constructor_C2Tuple_BlockHashChannelManagerZ_read(ser: Uint8Array, arg_keys_manager: KeysInterface, arg_fee_estimator: FeeEstimator, arg_chain_monitor: Watch, arg_tx_broadcaster: BroadcasterInterface, arg_logger: Logger, arg_default_config: UserConfig, arg_channel_monitors: ChannelMonitor[]): Result_C2Tuple_BlockHashChannelManagerZDecodeErrorZ;
    /**
     * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment`], but no
     * `ChannelManager` is required. Useful for generating invoices for [phantom node payments] without
     * a `ChannelManager`.
     *
     * `keys` is generated by calling [`KeysInterface::get_inbound_payment_key_material`] and then
     * calling [`ExpandedKey::new`] with its result. It is recommended to cache this value and not
     * regenerate it for each new inbound payment.
     *
     * `current_time` is a Unix timestamp representing the current time.
     *
     * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
     */
    static constructor_create(keys: ExpandedKey, min_value_msat: Option_u64Z, invoice_expiry_delta_secs: number, keys_manager: KeysInterface, current_time: bigint): Result_C2Tuple_PaymentHashPaymentSecretZNoneZ;
    /**
     * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash`],
     * but no `ChannelManager` is required. Useful for generating invoices for [phantom node payments]
     * without a `ChannelManager`.
     *
     * See [`create`] for information on the `keys` and `current_time` parameters.
     *
     * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
     */
    static constructor_create_from_hash(keys: ExpandedKey, min_value_msat: Option_u64Z, payment_hash: Uint8Array, invoice_expiry_delta_secs: number, current_time: bigint): Result_PaymentSecretNoneZ;
    /**
     * Gets the weight for an HTLC-Success transaction.
     */
    static constructor_htlc_success_tx_weight(opt_anchors: boolean): bigint;
    /**
     * Gets the weight for an HTLC-Timeout transaction.
     */
    static constructor_htlc_timeout_tx_weight(opt_anchors: boolean): bigint;
    /**
     * Build the commitment secret from the seed and the commitment number
     */
    static constructor_build_commitment_secret(commitment_seed: Uint8Array, idx: bigint): Uint8Array;
    /**
     * Build a closing transaction
     */
    static constructor_build_closing_transaction(to_holder_value_sat: bigint, to_counterparty_value_sat: bigint, to_holder_script: Uint8Array, to_counterparty_script: Uint8Array, funding_outpoint: OutPoint): Uint8Array;
    /**
     * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
     * from the base secret and the per_commitment_point.
     *
     * Note that this is infallible iff we trust that at least one of the two input keys are randomly
     * generated (ie our own).
     */
    static constructor_derive_private_key(per_commitment_point: Uint8Array, base_secret: Uint8Array): Result_SecretKeyErrorZ;
    /**
     * Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
     * from the base point and the per_commitment_key. This is the public equivalent of
     * derive_private_key - using only public keys to derive a public key instead of private keys.
     *
     * Note that this is infallible iff we trust that at least one of the two input keys are randomly
     * generated (ie our own).
     */
    static constructor_derive_public_key(per_commitment_point: Uint8Array, base_point: Uint8Array): Result_PublicKeyErrorZ;
    /**
     * Derives a per-commitment-transaction revocation key from its constituent parts.
     *
     * Only the cheating participant owns a valid witness to propagate a revoked
     * commitment transaction, thus per_commitment_secret always come from cheater
     * and revocation_base_secret always come from punisher, which is the broadcaster
     * of the transaction spending with this key knowledge.
     *
     * Note that this is infallible iff we trust that at least one of the two input keys are randomly
     * generated (ie our own).
     */
    static constructor_derive_private_revocation_key(per_commitment_secret: Uint8Array, countersignatory_revocation_base_secret: Uint8Array): Result_SecretKeyErrorZ;
    /**
     * Derives a per-commitment-transaction revocation public key from its constituent parts. This is
     * the public equivalend of derive_private_revocation_key - using only public keys to derive a
     * public key instead of private keys.
     *
     * Only the cheating participant owns a valid witness to propagate a revoked
     * commitment transaction, thus per_commitment_point always come from cheater
     * and revocation_base_point always come from punisher, which is the broadcaster
     * of the transaction spending with this key knowledge.
     *
     * Note that this is infallible iff we trust that at least one of the two input keys are randomly
     * generated (ie our own).
     */
    static constructor_derive_public_revocation_key(per_commitment_point: Uint8Array, countersignatory_revocation_base_point: Uint8Array): Result_PublicKeyErrorZ;
    /**
     * A script either spendable by the revocation
     * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
     * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
     */
    static constructor_get_revokeable_redeemscript(revocation_key: Uint8Array, contest_delay: number, broadcaster_delayed_payment_key: Uint8Array): Uint8Array;
    /**
     * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
     * does not need to have its previous_output_index filled.
     */
    static constructor_get_htlc_redeemscript(htlc: HTLCOutputInCommitment, opt_anchors: boolean, keys: TxCreationKeys): Uint8Array;
    /**
     * Gets the redeemscript for a funding output from the two funding public keys.
     * Note that the order of funding public keys does not matter.
     */
    static constructor_make_funding_redeemscript(broadcaster: Uint8Array, countersignatory: Uint8Array): Uint8Array;
    /**
     * Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
     * parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
     * transaction which needs signing, and can be used to construct an HTLC transaction which is
     * broadcastable given a counterparty HTLC signature.
     *
     * Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
     * commitment transaction).
     */
    static constructor_build_htlc_transaction(commitment_txid: Uint8Array, feerate_per_kw: number, contest_delay: number, htlc: HTLCOutputInCommitment, opt_anchors: boolean, broadcaster_delayed_payment_key: Uint8Array, revocation_key: Uint8Array): Uint8Array;
    /**
     * Gets the witnessScript for an anchor output from the funding public key.
     * The witness in the spending input must be:
     * <BIP 143 funding_signature>
     * After 16 blocks of confirmation, an alternative satisfying witness could be:
     * <>
     * (empty vector required to satisfy compliance with MINIMALIF-standard rule)
     */
    static constructor_get_anchor_redeemscript(funding_pubkey: Uint8Array): Uint8Array;
    /**
     * Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
     * shared secret first. This prevents on-chain observers from discovering how many commitment
     * transactions occurred in a channel before it was closed.
     *
     * This function gets the shared secret from relevant channel public keys and can be used to
     * \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
     */
    static constructor_get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint: Uint8Array, countersignatory_payment_basepoint: Uint8Array, outbound_from_broadcaster: boolean): bigint;
    /**
     * Read a NetworkUpdate from a byte array, created by NetworkUpdate_write
     */
    static constructor_NetworkUpdate_read(ser: Uint8Array): Result_COption_NetworkUpdateZDecodeErrorZ;
    /**
     * Finds a route from us (payer) to the given target node (payee).
     *
     * If the payee provided features in their invoice, they should be provided via `params.payee`.
     * Without this, MPP will only be used if the payee's features are available in the network graph.
     *
     * Private routing paths between a public node and the target may be included in `params.payee`.
     *
     * If some channels aren't announced, it may be useful to fill in `first_hops` with the results
     * from [`ChannelManager::list_usable_channels`]. If it is filled in, the view of these channels
     * from `network_graph` will be ignored, and only those in `first_hops` will be used.
     *
     * The fees on channels from us to the next hop are ignored as they are assumed to all be equal.
     * However, the enabled/disabled bit on such channels as well as the `htlc_minimum_msat` /
     * `htlc_maximum_msat` *are* checked as they may change based on the receiving node.
     *
     * # Note
     *
     * May be used to re-compute a [`Route`] when handling a [`Event::PaymentPathFailed`]. Any
     * adjustments to the [`NetworkGraph`] and channel scores should be made prior to calling this
     * function.
     *
     * # Panics
     *
     * Panics if first_hops contains channels without short_channel_ids;
     * [`ChannelManager::list_usable_channels`] will never include such channels.
     *
     * [`ChannelManager::list_usable_channels`]: crate::ln::channelmanager::ChannelManager::list_usable_channels
     * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
     * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
     *
     * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    static constructor_find_route(our_node_pubkey: Uint8Array, route_params: RouteParameters, network_graph: NetworkGraph, first_hops: ChannelDetails[], logger: Logger, scorer: Score, random_seed_bytes: Uint8Array): Result_RouteLightningErrorZ;
    /**
     * Construct a route from us (payer) to the target node (payee) via the given hops (which should
     * exclude the payer, but include the payee). This may be useful, e.g., for probing the chosen path.
     *
     * Re-uses logic from `find_route`, so the restrictions described there also apply here.
     */
    static constructor_build_route_from_hops(our_node_pubkey: Uint8Array, hops: Uint8Array[], route_params: RouteParameters, network_graph: NetworkGraph, logger: Logger, random_seed_bytes: Uint8Array): Result_RouteLightningErrorZ;
    /**
     * See [`create_invoice_from_channelmanager_with_description_hash`]
     * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
     * available and the current time is supplied by the caller.
     */
    static constructor_create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(channelmanager: ChannelManager, keys_manager: KeysInterface, network: Currency, amt_msat: Option_u64Z, description_hash: Sha256, duration_since_epoch: bigint, invoice_expiry_delta_secs: number): Result_InvoiceSignOrCreationErrorZ;
    /**
     * See [`create_invoice_from_channelmanager`]
     * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
     * available and the current time is supplied by the caller.
     */
    static constructor_create_invoice_from_channelmanager_and_duration_since_epoch(channelmanager: ChannelManager, keys_manager: KeysInterface, network: Currency, amt_msat: Option_u64Z, description: string, duration_since_epoch: bigint, invoice_expiry_delta_secs: number): Result_InvoiceSignOrCreationErrorZ;
}
