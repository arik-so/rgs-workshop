import { Result_NoneLightningErrorZ } from '../structs/Result_NoneLightningErrorZ.mjs';
import { Type } from '../structs/Type.mjs';
import { TwoTuple_PublicKeyTypeZ } from '../structs/TwoTuple_PublicKeyTypeZ.mjs';
import { CustomMessageReader } from '../structs/CustomMessageReader.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKCustomMessageHandlerHolder {
}
/**
 * Handler for BOLT1-compliant messages.
 */
export class CustomMessageHandler extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.CustomMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of CustomMessageHandler from a given implementation */
    static new_impl(arg, customMessageReader_impl) {
        const impl_holder = new LDKCustomMessageHandlerHolder();
        let structImplementation = {
            handle_custom_message(msg, sender_node_id) {
                const ret_hu_conv = new Type(null, msg);
                CommonBase.add_ref_from(ret_hu_conv, this);
                const sender_node_id_conv = bindings.decodeUint8Array(sender_node_id);
                const ret = arg.handle_custom_message(ret_hu_conv, sender_node_id_conv);
                const result = ret == null ? 0n : ret.clone_ptr();
                return result;
            },
            get_and_clear_pending_msg() {
                const ret = arg.get_and_clear_pending_msg();
                const result = bindings.encodeUint64Array(ret != null ? ret.map(ret_conv_25 => ret_conv_25 == null ? 0n : ret_conv_25.clone_ptr()) : null);
                return result;
            },
        };
        const customMessageReader = CustomMessageReader.new_impl(customMessageReader_impl);
        const ptr_idx = bindings.LDKCustomMessageHandler_new(structImplementation, customMessageReader.instance_idx);
        impl_holder.held = new CustomMessageHandler(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(customMessageReader);
        return impl_holder.held;
    }
    /**
     * Called with the message type that was received and the buffer to be read.
     * Can return a `MessageHandlingError` if the message could not be handled.
     */
    handle_custom_message(msg, sender_node_id) {
        const ret = bindings.CustomMessageHandler_handle_custom_message(this.ptr, msg == null ? 0n : CommonBase.get_ptr_of(msg), bindings.encodeUint8Array(bindings.check_arr_len(sender_node_id, 33)));
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Gets the list of pending messages which were generated by the custom message
     * handler, clearing the list in the process. The first tuple element must
     * correspond to the intended recipients node ids. If no connection to one of the
     * specified node does not exist, the message is simply not sent to it.
     */
    get_and_clear_pending_msg() {
        const ret = bindings.CustomMessageHandler_get_and_clear_pending_msg(this.ptr);
        const ret_conv_25_len = bindings.getArrayLength(ret);
        const ret_conv_25_arr = new Array(ret_conv_25_len).fill(null);
        for (var z = 0; z < ret_conv_25_len; z++) {
            const ret_conv_25 = bindings.getU64ArrayElem(ret, z);
            const ret_conv_25_hu_conv = new TwoTuple_PublicKeyTypeZ(null, ret_conv_25);
            CommonBase.add_ref_from(ret_conv_25_hu_conv, this);
            ret_conv_25_arr[z] = ret_conv_25_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_25_arr;
    }
}
//# sourceMappingURL=CustomMessageHandler.mjs.map